-- =====================================
-- 리뷰 자동화 SaaS 서비스 데이터베이스 스키마
-- =====================================

-- =====================================
-- 1. 사용자 관리 테이블
-- =====================================

-- 사용자 기본 정보 테이블
-- 역할: 서비스 회원가입한 모든 사용자의 기본 정보 관리
-- 사장님, 영업자, 프랜차이즈 매니저, 시스템 관리자 등 모든 사용자 통합 관리
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    user_code VARCHAR(50) UNIQUE NOT NULL,          -- 사용자 고유 코드 (USR001, USR002...)
    email VARCHAR(100) UNIQUE NOT NULL,             -- 로그인용 이메일 (중복 불가)
    password_hash VARCHAR(255) NOT NULL,            -- 암호화된 비밀번호
    name VARCHAR(100) NOT NULL,                     -- 사용자 실명
    phone VARCHAR(20),                              -- 연락처 (알림 발송용)
    role VARCHAR(20) NOT NULL,                      -- 역할: 'admin'(관리자), 'franchise'(프랜차이즈), 'sales'(영업자), 'owner'(사장님)
    company_name VARCHAR(100),                      -- 소속 회사명 (프랜차이즈, 영업회사 등)
    email_verified BOOLEAN DEFAULT false,           -- 이메일 인증 완료 여부
    phone_verified BOOLEAN DEFAULT false,           -- 휴대폰 인증 완료 여부
    signup_date DATE DEFAULT CURRENT_DATE,          -- 회원가입 일자
    last_login TIMESTAMP,                           -- 마지막 로그인 시간
    login_count INTEGER DEFAULT 0,                  -- 총 로그인 횟수
    is_active BOOLEAN DEFAULT true,                 -- 계정 활성화 상태
    profile_image_url TEXT,                         -- 프로필 이미지 URL
    timezone VARCHAR(50) DEFAULT 'Asia/Seoul',      -- 사용자 시간대
    language VARCHAR(10) DEFAULT 'ko',              -- 사용 언어
    marketing_consent BOOLEAN DEFAULT false,        -- 마케팅 수신 동의
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- =====================================
-- 2. 구독 및 결제 관리 테이블
-- =====================================

-- 요금제 정보 테이블
-- 역할: 서비스에서 제공하는 모든 요금제의 상세 정보 관리
-- 베이직, 프로, 엔터프라이즈 등 각 요금제별 기능과 제한사항 정의
CREATE TABLE pricing_plans (
    id SERIAL PRIMARY KEY,
    plan_code VARCHAR(50) UNIQUE NOT NULL,          -- 요금제 코드 (FREE_TRIAL, BASIC, PRO, ENTERPRISE)
    plan_name VARCHAR(100) NOT NULL,                -- 요금제 이름 (무료체험, 베이직, 프로, 엔터프라이즈)
    description TEXT,                               -- 요금제 상세 설명
    monthly_price DECIMAL(10,2) NOT NULL,          -- 월 요금 (원)
    yearly_price DECIMAL(10,2),                    -- 연간 결제시 할인가 (원)
    yearly_discount_rate INTEGER DEFAULT 0,         -- 연간 결제 할인율 (%)
    max_stores INTEGER NOT NULL,                    -- 최대 관리 가능 매장 수
    max_reviews_per_month INTEGER NOT NULL,         -- 월 최대 답글 처리 한도
    max_users INTEGER DEFAULT 1,                    -- 최대 사용자 수 (팀 계정용)
    features JSONB,                                 -- 포함 기능들 JSON {"ai_reply": true, "analytics": true, "api_access": false}
    api_rate_limit INTEGER DEFAULT 0,               -- API 시간당 호출 한도 (0=제한없음)
    priority_support BOOLEAN DEFAULT false,         -- 우선 고객지원 여부
    custom_branding BOOLEAN DEFAULT false,          -- 커스텀 브랜딩 제공 여부
    is_popular BOOLEAN DEFAULT false,               -- 인기 요금제 표시 여부
    is_active BOOLEAN DEFAULT true,                 -- 요금제 활성화 상태
    sort_order INTEGER DEFAULT 0,                   -- 요금제 표시 순서
    trial_days INTEGER DEFAULT 0,                   -- 무료 체험 기간 (일)
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 사용자 구독 정보 테이블
-- 역할: 각 사용자의 현재 구독 상태와 이력 관리
-- 구독 시작/종료일, 결제 주기, 자동갱신 설정 등 구독 생명주기 전체 관리
CREATE TABLE subscriptions (
    id SERIAL PRIMARY KEY,
    subscription_code VARCHAR(50) UNIQUE NOT NULL,  -- 구독 고유 코드
    user_code VARCHAR(50) NOT NULL,                 -- 구독 소유자
    plan_code VARCHAR(50) NOT NULL,                 -- 현재 구독중인 요금제
    status VARCHAR(20) NOT NULL,                    -- 구독 상태: 'active'(활성), 'expired'(만료), 'cancelled'(취소), 'trial'(체험), 'payment_failed'(결제실패), 'paused'(일시정지)
    billing_cycle VARCHAR(10) NOT NULL,             -- 결제 주기: 'monthly'(월간), 'yearly'(연간)
    start_date DATE NOT NULL,                       -- 구독 시작일
    end_date DATE NOT NULL,                         -- 구독 종료일
    trial_start_date DATE,                          -- 무료 체험 시작일
    trial_end_date DATE,                           -- 무료 체험 종료일
    auto_renewal BOOLEAN DEFAULT true,              -- 자동 갱신 여부
    payment_amount DECIMAL(10,2) NOT NULL,         -- 실제 결제 금액 (할인 적용후)
    original_amount DECIMAL(10,2),                 -- 원래 요금 (할인 적용전)
    discount_amount DECIMAL(10,2) DEFAULT 0,       -- 할인 금액
    discount_code VARCHAR(50),                      -- 사용된 할인 쿠폰 코드
    currency VARCHAR(3) DEFAULT 'KRW',             -- 통화 (KRW, USD 등)
    next_billing_date DATE,                        -- 다음 결제 예정일
    cancellation_date DATE,                        -- 취소 신청일 (즉시취소 vs 만료시취소)
    cancellation_reason TEXT,                      -- 취소 사유
    cancellation_type VARCHAR(20),                 -- 취소 유형: 'immediate'(즉시), 'end_of_period'(기간만료시)
    downgrade_scheduled_plan VARCHAR(50),          -- 예약된 다운그레이드 요금제
    upgrade_effective_date DATE,                   -- 업그레이드 적용일
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (user_code) REFERENCES users(user_code),
    FOREIGN KEY (plan_code) REFERENCES pricing_plans(plan_code)
);

-- 결제 내역 테이블
-- 역할: 모든 결제 시도와 결과를 상세하게 기록
-- 성공/실패/환불 등 모든 결제 이벤트 추적하여 매출 분석과 문제 해결에 활용
CREATE TABLE payments (
    id SERIAL PRIMARY KEY,
    payment_code VARCHAR(50) UNIQUE NOT NULL,       -- 결제 고유 코드
    subscription_code VARCHAR(50) NOT NULL,         -- 해당 구독
    user_code VARCHAR(50) NOT NULL,                 -- 결제자
    payment_type VARCHAR(20) NOT NULL,              -- 결제 유형: 'subscription'(구독료), 'upgrade'(업그레이드), 'addon'(추가기능)
    amount DECIMAL(10,2) NOT NULL,                  -- 결제 금액
    currency VARCHAR(3) DEFAULT 'KRW',              -- 통화
    payment_method VARCHAR(20),                     -- 결제 수단: 'card'(카드), 'bank_transfer'(계좌이체), 'kakao_pay'(카카오페이), 'paypal'(페이팔)
    payment_gateway VARCHAR(20),                    -- 결제 게이트웨이: 'toss'(토스페이먼츠), 'iamport'(아임포트), 'stripe'(스트라이프)
    gateway_transaction_id VARCHAR(100),            -- 결제 게이트웨이 거래 ID
    merchant_uid VARCHAR(100),                      -- 가맹점 주문번호
    status VARCHAR(20) NOT NULL,                    -- 결제 상태: 'pending'(대기), 'completed'(완료), 'failed'(실패), 'cancelled'(취소), 'refunded'(환불)
    paid_at TIMESTAMP,                              -- 결제 완료 시간
    failed_at TIMESTAMP,                            -- 결제 실패 시간
    cancelled_at TIMESTAMP,                         -- 결제 취소 시간
    refunded_at TIMESTAMP,                          -- 환불 완료 시간
    refund_amount DECIMAL(10,2) DEFAULT 0,          -- 환불 금액
    failure_reason TEXT,                            -- 결제 실패 사유
    receipt_url TEXT,                               -- 결제 영수증 URL
    card_info JSONB,                                -- 카드 정보 (마스킹된 정보) {"brand": "VISA", "last4": "1234"}
    billing_address JSONB,                         -- 청구지 주소
    invoice_number VARCHAR(50),                     -- 세금계산서 번호
    vat_amount DECIMAL(10,2) DEFAULT 0,             -- 부가세 금액
    webhook_attempts INTEGER DEFAULT 0,             -- 웹훅 재시도 횟수
    created_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (subscription_code) REFERENCES subscriptions(subscription_code),
    FOREIGN KEY (user_code) REFERENCES users(user_code)
);

-- 할인 쿠폰 테이블
-- 역할: 마케팅 캠페인용 할인 쿠폰 관리
-- 신규가입, 업그레이드, 재가입 등 다양한 시나리오에서 사용할 할인 혜택 제공
CREATE TABLE discount_coupons (
    id SERIAL PRIMARY KEY,
    coupon_code VARCHAR(50) UNIQUE NOT NULL,        -- 쿠폰 코드 (사용자 입력용)
    coupon_name VARCHAR(100) NOT NULL,              -- 쿠폰 이름 (관리용)
    description TEXT,                               -- 쿠폰 설명
    discount_type VARCHAR(20) NOT NULL,             -- 할인 유형: 'percentage'(비율), 'fixed'(고정금액), 'free_trial'(무료체험연장)
    discount_value DECIMAL(10,2) NOT NULL,          -- 할인 값 (percentage: 10=10%, fixed: 10000=1만원)
    max_discount_amount DECIMAL(10,2),              -- 최대 할인 한도 (비율 할인시)
    applicable_plans TEXT[],                        -- 적용 가능한 요금제 목록 (빈 배열=모든 요금제)
    min_subscription_months INTEGER DEFAULT 1,      -- 최소 구독 개월 수
    valid_from DATE NOT NULL,                       -- 쿠폰 유효 시작일
    valid_until DATE NOT NULL,                      -- 쿠폰 유효 종료일
    usage_limit INTEGER,                            -- 총 사용 한도 (NULL=무제한)
    used_count INTEGER DEFAULT 0,                   -- 현재까지 사용 횟수
    usage_limit_per_user INTEGER DEFAULT 1,         -- 사용자당 사용 한도
    is_active BOOLEAN DEFAULT true,                 -- 쿠폰 활성화 상태
    created_by VARCHAR(50),                         -- 쿠폰 생성자 (관리자)
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 쿠폰 사용 이력 테이블
-- 역할: 각 쿠폰의 사용 이력을 상세하게 추적
-- 중복 사용 방지, 사용 통계 분석, 마케팅 효과 측정에 활용
CREATE TABLE coupon_usage_history (
    id SERIAL PRIMARY KEY,
    coupon_code VARCHAR(50) NOT NULL,               -- 사용된 쿠폰 코드
    user_code VARCHAR(50) NOT NULL,                 -- 쿠폰 사용자
    subscription_code VARCHAR(50),                  -- 쿠폰이 적용된 구독
    payment_code VARCHAR(50),                       -- 쿠폰이 적용된 결제
    discount_amount DECIMAL(10,2) NOT NULL,         -- 실제 할인받은 금액
    used_at TIMESTAMP DEFAULT NOW(),                -- 쿠폰 사용 시간
    FOREIGN KEY (user_code) REFERENCES users(user_code),
    FOREIGN KEY (subscription_code) REFERENCES subscriptions(subscription_code),
    FOREIGN KEY (payment_code) REFERENCES payments(payment_code)
);

-- =====================================
-- 3. 사용량 추적 및 제한 관리 테이블
-- =====================================

-- 월별 사용량 추적 테이블
-- 역할: 각 사용자의 월별 서비스 사용량을 상세하게 추적
-- 요금제별 한도 확인, 과사용 방지, 사용 패턴 분석에 활용
CREATE TABLE usage_tracking (
    id SERIAL PRIMARY KEY,
    user_code VARCHAR(50) NOT NULL,                 -- 사용자
    tracking_month DATE NOT NULL,                   -- 추적 월 (YYYY-MM-01 형식으로 저장)
    stores_count INTEGER DEFAULT 0,                 -- 해당 월에 등록된 매장 수
    reviews_processed INTEGER DEFAULT 0,            -- 해당 월에 AI로 처리한 답글 수
    manual_replies INTEGER DEFAULT 0,               -- 해당 월에 수동으로 작성한 답글 수
    ai_api_calls INTEGER DEFAULT 0,                 -- 해당 월 AI API 호출 횟수
    web_api_calls INTEGER DEFAULT 0,                -- 해당 월 웹 API 호출 횟수
    error_count INTEGER DEFAULT 0,                  -- 해당 월 발생한 에러 수
    success_rate DECIMAL(5,2) DEFAULT 0,            -- 해당 월 답글 성공률 (%)
    average_response_time INTEGER DEFAULT 0,        -- 평균 응답 처리 시간 (초)
    peak_concurrent_stores INTEGER DEFAULT 0,       -- 최대 동시 처리 매장 수
    data_transfer_mb INTEGER DEFAULT 0,             -- 데이터 전송량 (MB)
    storage_used_mb INTEGER DEFAULT 0,              -- 스토리지 사용량 (MB)
    last_activity TIMESTAMP,                        -- 마지막 활동 시간
    last_updated TIMESTAMP DEFAULT NOW(),           -- 마지막 업데이트 시간
    FOREIGN KEY (user_code) REFERENCES users(user_code),
    UNIQUE(user_code, tracking_month)              -- 사용자별 월별 하나의 레코드만 허용
);

-- 실시간 사용량 제한 테이블
-- 역할: 실시간으로 사용량 한도를 체크하여 서비스 남용 방지
-- API 호출, 동시 접속, 처리량 등에 대한 실시간 제한 적용
CREATE TABLE rate_limits (
    id SERIAL PRIMARY KEY,
    user_code VARCHAR(50) NOT NULL,                 -- 사용자
    limit_type VARCHAR(50) NOT NULL,                -- 제한 유형: 'api_calls', 'concurrent_stores', 'reviews_per_hour'
    current_count INTEGER DEFAULT 0,                -- 현재 사용량
    max_limit INTEGER NOT NULL,                     -- 최대 허용량
    reset_period VARCHAR(20) NOT NULL,              -- 리셋 주기: 'hourly', 'daily', 'monthly'
    reset_at TIMESTAMP NOT NULL,                    -- 다음 리셋 시간
    blocked_until TIMESTAMP,                        -- 일시적 차단 해제 시간
    violations_count INTEGER DEFAULT 0,             -- 제한 위반 횟수
    last_violation TIMESTAMP,                       -- 마지막 위반 시간
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (user_code) REFERENCES users(user_code),
    UNIQUE(user_code, limit_type)
);

-- =====================================
-- 4. 매장 및 답글 관리 테이블
-- =====================================

-- 매장별 답글 설정 테이블 (기존 platform_reply_rules 개선)
-- 역할: 각 사장님 계정별로 관리하는 모든 매장의 답글 정책과 로그인 정보 관리
-- 하나의 계정(store_code)으로 여러 매장(platform_code) 관리 가능
CREATE TABLE platform_reply_rules (
    id SERIAL PRIMARY KEY,
    store_code VARCHAR(50) NOT NULL,                -- 사장님 계정 코드 (여러 매장 관리용)
    store_name VARCHAR(100) NOT NULL,               -- 매장 이름
    platform VARCHAR(20) NOT NULL,                 -- 플랫폼: 'baemin'(배민), 'yogiyo'(요기요), 'coupang'(쿠팡이츠)
    platform_code VARCHAR(50) NOT NULL,            -- 플랫폼상의 매장 고유 ID (URL에 사용되는 ID)
    platform_id VARCHAR(100) NOT NULL,             -- 플랫폼 로그인 아이디
    platform_pw VARCHAR(100) NOT NULL,             -- 플랫폼 로그인 비밀번호 (암호화 저장)
    owner_user_code VARCHAR(50) NOT NULL,          -- 매장 소유자 (users 테이블 연결)
    store_type VARCHAR(50) DEFAULT 'delivery_only', -- 매장 유형: 'delivery_only'(배달전용), 'dine_in'(홀포함)
    
    -- 답글 정책 설정
    greeting_start TEXT DEFAULT '안녕하세요',       -- 답글 시작 인사말
    greeting_end TEXT,                             -- 답글 마무리 인사말
    role TEXT DEFAULT '',                          -- AI 역할 설정 (친근한 사장님, 정중한 직원 등)
    tone TEXT DEFAULT '',                          -- 답글 톤앤매너 (친근함, 정중함, 격식있음 등)
    prohibited_words TEXT[],                       -- 답글에 사용 금지할 단어 목록
    max_length INTEGER DEFAULT 300,                -- 답글 최대 길이 (글자 수)
    
    -- 별점별 자동 답글 활성화 설정
    rating_5_reply BOOLEAN DEFAULT true,           -- 5점 리뷰 자동 답글 여부
    rating_4_reply BOOLEAN DEFAULT true,           -- 4점 리뷰 자동 답글 여부
    rating_3_reply BOOLEAN DEFAULT true,           -- 3점 리뷰 자동 답글 여부
    rating_2_reply BOOLEAN DEFAULT true,           -- 2점 리뷰 자동 답글 여부
    rating_1_reply BOOLEAN DEFAULT true,           -- 1점 리뷰 자동 답글 여부
    
    -- 운영 설정
    auto_reply_enabled BOOLEAN DEFAULT true,       -- 자동 답글 기능 활성화 여부
    auto_reply_hours VARCHAR(20) DEFAULT '10:00-20:00', -- 자동 답글 운영 시간
    reply_delay_minutes INTEGER DEFAULT 30,        -- 답글 등록 지연 시간 (분)
    weekend_enabled BOOLEAN DEFAULT true,          -- 주말 운영 여부
    holiday_enabled BOOLEAN DEFAULT false,         -- 공휴일 운영 여부
    
    -- 품질 관리
    quality_check_enabled BOOLEAN DEFAULT true,    -- 답글 품질 검사 활성화
    manual_review_threshold DECIMAL(3,2) DEFAULT 0.3, -- 수동 검토 임계점 (0.0~1.0)
    learning_mode BOOLEAN DEFAULT false,           -- 학습 모드 (답글 등록 전 확인)
    
    -- 메타 정보
    last_crawled TIMESTAMP,                        -- 마지막 크롤링 시간
    last_reply TIMESTAMP,                          -- 마지막 답글 등록 시간
    total_reviews_processed INTEGER DEFAULT 0,     -- 총 처리한 리뷰 수
    avg_rating DECIMAL(3,2),                       -- 평균 별점
    is_active BOOLEAN DEFAULT true,                -- 매장 활성화 상태
    is_suspended BOOLEAN DEFAULT false,            -- 일시 정지 여부 (위반시)
    suspension_reason TEXT,                        -- 정지 사유
    notes TEXT,                                    -- 관리자 메모
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (owner_user_code) REFERENCES users(user_code)
);

-- 사용자-매장 권한 관리 테이블
-- 역할: 영업자, 프랜차이즈 매니저 등이 여러 사장님의 매장을 관리할 수 있도록 권한 부여
-- N:N 관계로 한 사용자가 여러 매장을, 한 매장을 여러 사용자가 관리 가능
CREATE TABLE user_store_permissions (
    id SERIAL PRIMARY KEY,
    user_code VARCHAR(50) NOT NULL,                 -- 권한을 받는 사용자
    store_code VARCHAR(50) NOT NULL,                -- 관리 대상 매장 계정
    permission_level VARCHAR(20) NOT NULL,          -- 권한 레벨: 'read'(조회), 'write'(편집), 'admin'(관리)
    
    -- 세부 권한 설정
    can_view BOOLEAN DEFAULT true,                  -- 매장 정보 및 리뷰 조회 권한
    can_edit_settings BOOLEAN DEFAULT false,        -- 답글 정책 및 설정 편집 권한
    can_reply BOOLEAN DEFAULT false,                -- 수동 답글 작성 권한
    can_manage_rules BOOLEAN DEFAULT false,         -- 답글 규칙 관리 권한
    can_manage_alerts BOOLEAN DEFAULT false,        -- 알림 설정 관리 권한
    can_view_analytics BOOLEAN DEFAULT false,       -- 분석 리포트 조회 권한
    can_export_data BOOLEAN DEFAULT false,          -- 데이터 내보내기 권한
    can_manage_users BOOLEAN DEFAULT false,         -- 다른 사용자 권한 관리 (관리자용)
    
    -- 권한 부여 정보
    granted_by VARCHAR(50),                         -- 권한을 부여한 사용자
    granted_at TIMESTAMP DEFAULT NOW(),             -- 권한 부여 시간
    expires_at TIMESTAMP,                           -- 권한 만료 시간 (NULL=무제한)
    last_accessed TIMESTAMP,                        -- 마지막 접근 시간
    access_count INTEGER DEFAULT 0,                 -- 총 접근 횟수
    
    -- 제한 설정
    ip_whitelist TEXT[],                            -- 접근 허용 IP 목록 (빈 배열=제한없음)
    time_restrictions JSONB,                        -- 시간 제한 {"start": "09:00", "end": "18:00", "days": ["mon", "tue"]}
    is_active BOOLEAN DEFAULT true,                 -- 권한 활성화 상태
    
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (user_code) REFERENCES users(user_code),
    FOREIGN KEY (granted_by) REFERENCES users(user_code),
    UNIQUE(user_code, store_code)                   -- 사용자-매장 조합별 하나의 권한만 허용
);

-- =====================================
-- 5. 리뷰 및 답글 데이터 테이블
-- =====================================

-- 리뷰 및 답글 데이터 테이블
-- 역할: 크롤링한 모든 리뷰와 AI/수동으로 작성한 답글을 저장
-- 리뷰 분석, 답글 품질 관리, 성과 측정의 핵심 데이터
CREATE TABLE reviews (
    id SERIAL PRIMARY KEY,
    review_id VARCHAR(100) UNIQUE NOT NULL,         -- 리뷰 고유 식별자 (해시값)
    store_code VARCHAR(50) NOT NULL,                -- 매장 계정 코드
    platform VARCHAR(20) NOT NULL,                 -- 플랫폼명
    platform_code VARCHAR(50) NOT NULL,            -- 플랫폼상의 매장 ID
    
    -- 리뷰 기본 정보
    review_name VARCHAR(100),                       -- 리뷰 작성자 닉네임
    rating INTEGER NOT NULL,                        -- 별점 (1~5)
    review_content TEXT,                           -- 리뷰 텍스트 내용
    ordered_menu TEXT,                             -- 주문한 메뉴 목록
    delivery_review TEXT,                          -- 배달 관련 리뷰 (빠름/보통/늦음)
    review_date DATE NOT NULL,                     -- 리뷰 작성일
    review_images TEXT[],                          -- 리뷰 이미지 URL 목록
    
    -- AI 분석 결과
    sentiment_score DECIMAL(3,2),                  -- 감정 점수 (0.0=매우부정 ~ 1.0=매우긍정)
    review_category VARCHAR(50),                   -- 리뷰 카테고리 (음식품질, 배달서비스, 가격 등)
    keywords TEXT[],                               -- 추출된 키워드 목록
    urgency_level VARCHAR(20),                     -- 긴급도: 'low', 'medium', 'high', 'critical'
    
    -- 답글 정보
    ai_response TEXT,                              -- AI가 생성한 답글
    manual_response TEXT,                          -- 수동으로 작성한 답글 (AI 답글 수정 포함)
    final_response TEXT,                           -- 실제로 등록된 최종 답글
    response_status VARCHAR(50) NOT NULL,          -- 답글 상태: 'pending'(대기), 'generated'(생성됨), 'posted'(등록됨), 'failed'(실패), 'manual_required'(수동필요)
    response_method VARCHAR(20),                   -- 답글 방식: 'ai_auto', 'ai_manual', 'full_manual'
    response_at TIMESTAMP,                         -- 답글 등록 시간
    response_by VARCHAR(50),                       -- 답글 작성자 (AI 또는 사용자 코드)
    
    -- 품질 및 성과
    response_quality_score DECIMAL(3,2),           -- 답글 품질 점수 (0.0~1.0)
    customer_reaction VARCHAR(20),                 -- 고객 반응: 'positive', 'negative', 'neutral', 'unknown'
    follow_up_required BOOLEAN DEFAULT false,      -- 추가 조치 필요 여부
    
    -- 처리 관리
    boss_reply_needed BOOLEAN DEFAULT false,       -- 사장님 직접 확인 필요 여부
    review_reason TEXT,                            -- 수동 확인이 필요한 이유
    retry_count INTEGER DEFAULT 0,                 -- 답글 등록 재시도 횟수
    last_retry_at TIMESTAMP,                       -- 마지막 재시도 시간
    error_message TEXT,                            -- 마지막 에러 메시지
    processing_duration INTEGER,                   -- 처리 소요 시간 (초)
    
    -- 메타 정보
    crawled_at TIMESTAMP DEFAULT NOW(),            -- 크롤링 시간
    processed_at TIMESTAMP,                        -- AI 처리 완료 시간
    is_deleted BOOLEAN DEFAULT false,              -- 삭제 여부 (실제 삭제 대신 플래그)
    deleted_at TIMESTAMP,                          -- 삭제 시간
    notes TEXT,                                    -- 관리자 메모
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 답글 생성 이력 테이블
-- 역할: AI 답글 생성 과정과 수정 이력을 상세하게 추적
-- 답글 품질 개선, A/B 테스트, 학습 데이터 수집에 활용
CREATE TABLE reply_generation_history (
    id SERIAL PRIMARY KEY,
    review_id VARCHAR(100) NOT NULL,                -- 대상 리뷰
    user_code VARCHAR(50),                          -- 수정한 사용자 (AI인 경우 NULL)
    generation_type VARCHAR(20) NOT NULL,           -- 생성 유형: 'ai_initial', 'ai_retry', 'manual_edit', 'manual_new'
    prompt_used TEXT,                               -- 사용된 AI 프롬프트
    model_version VARCHAR(50),                      -- 사용된 AI 모델 버전
    temperature DECIMAL(3,2),                       -- AI 모델 temperature 설정
    generated_content TEXT NOT NULL,                -- 생성된 답글 내용
    quality_score DECIMAL(3,2),                     -- 해당 답글의 품질 점수
    processing_time_ms INTEGER,                     -- 생성 소요 시간 (밀리초)
    token_usage INTEGER,                            -- 사용된 토큰 수 (비용 계산용)
    is_selected BOOLEAN DEFAULT false,              -- 최종 선택된 답글 여부
    rejection_reason TEXT,                          -- 거부된 경우 사유
    created_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (review_id) REFERENCES reviews(review_id),
    FOREIGN KEY (user_code) REFERENCES users(user_code)
);

-- =====================================
-- 6. 알림 및 모니터링 테이블
-- =====================================

-- 알림 설정 테이블
-- 역할: 사용자별, 매장별로 다양한 알림 채널과 조건을 설정
-- 이메일, SMS, 슬랙, 카카오톡 등 다중 채널 알림 지원
CREATE TABLE alert_settings (
    id SERIAL PRIMARY KEY,
    user_code VARCHAR(50) NOT NULL,                 -- 알림 받을 사용자
    store_code VARCHAR(50),                         -- 특정 매장 (NULL=모든 매장)
    platform_code VARCHAR(50),                     -- 특정 플랫폼 매장 (NULL=모든 플랫폼)
    alert_type VARCHAR(50) NOT NULL,                -- 알림 유형: 'boss_reply_needed', 'error', 'success', 'low_rating', 'high_volume', 'payment_failed'
    
    -- 채널 설정
    channel VARCHAR(20) NOT NULL,                   -- 알림 채널: 'email', 'sms', 'slack', 'kakaotalk', 'webhook', 'push'
    channel_config JSONB NOT NULL,                  -- 채널별 설정: {"webhook_url": "...", "phone": "...", "email": "..."}
    
    -- 알림 조건
    trigger_conditions JSONB,                       -- 발송 조건: {"min_rating": 2, "max_rating": 5, "keywords": ["불만"]}
    frequency_limit VARCHAR(20) DEFAULT 'immediate', -- 발송 빈도: 'immediate', 'hourly', 'daily', 'weekly'
    quiet_hours JSONB,                             -- 알림 제한 시간: {"start": "22:00", "end": "08:00"}
    max_per_day INTEGER DEFAULT 50,                -- 일일 최대 알림 수
    
    -- 우선순위 및 필터
    priority VARCHAR(10) DEFAULT 'normal',          -- 우선순위: 'low', 'normal', 'high', 'critical'
    is_active BOOLEAN DEFAULT true,                 -- 알림 활성화 상태
    last_sent TIMESTAMP,                            -- 마지막 발송 시간
    sent_count_today INTEGER DEFAULT 0,             -- 오늘 발송 횟수
    
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (user_code) REFERENCES users(user_code)
);

-- 알림 발송 로그 테이블
-- 역할: 모든 알림 발송 시도와 결과를 기록
-- 발송 성공률 모니터링, 문제 해결, 사용자 행동 분석에 활용
CREATE TABLE alert_logs (
    id SERIAL PRIMARY KEY,
    alert_setting_id INTEGER,                       -- 알림 설정 참조
    user_code VARCHAR(50) NOT NULL,                 -- 알림 받는 사용자
    store_code VARCHAR(50),                         -- 관련 매장
    platform_code VARCHAR(50),                     -- 관련 플랫폼 매장
    review_id VARCHAR(100),                         -- 관련 리뷰 (있는 경우)
    
    -- 알림 내용
    alert_type VARCHAR(50) NOT NULL,                -- 알림 유형
    channel VARCHAR(20) NOT NULL,                   -- 발송 채널
    recipient_info JSONB,                          -- 수신자 정보 (이메일, 전화번호 등)
    subject VARCHAR(200),                           -- 제목 (이메일, 푸시 등)
    message TEXT NOT NULL,                          -- 알림 메시지 내용
    priority VARCHAR(10) DEFAULT 'normal',          -- 우선순위
    
    -- 발송 처리
    status VARCHAR(20) NOT NULL,                    -- 발송 상태: 'pending', 'sent', 'delivered', 'failed', 'bounced'
    sent_at TIMESTAMP,                              -- 발송 시도 시간
    delivered_at TIMESTAMP,                         -- 수신 확인 시간
    failed_at TIMESTAMP,                            -- 실패 시간
    retry_count INTEGER DEFAULT 0,                  -- 재시도 횟수
    error_message TEXT,                             -- 에러 메시지
    
    -- 외부 서비스 정보
    external_message_id VARCHAR(100),               -- 외부 서비스의 메시지 ID
    response_data JSONB,                            -- 외부 서비스 응답 데이터
    delivery_cost DECIMAL(10,4),                    -- 발송 비용 (SMS, 알림톡 등)
    
    -- 사용자 반응
    opened_at TIMESTAMP,                            -- 알림 열람 시간
    clicked_at TIMESTAMP,                           -- 링크 클릭 시간
    action_taken VARCHAR(50),                       -- 사용자 액션: 'viewed', 'clicked', 'replied', 'ignored'
    
    created_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (alert_setting_id) REFERENCES alert_settings(id),
    FOREIGN KEY (user_code) REFERENCES users(user_code),
    FOREIGN KEY (review_id) REFERENCES reviews(review_id)
);

-- =====================================
-- 7. 시스템 모니터링 및 로그 테이블
-- =====================================

-- 에러 로그 테이블
-- 역할: 시스템에서 발생하는 모든 에러와 예외상황을 상세하게 기록
-- 시스템 안정성 모니터링, 문제 해결, 서비스 개선에 필수적인 데이터
CREATE TABLE error_logs (
    id SERIAL PRIMARY KEY,
    error_code VARCHAR(50),                         -- 에러 코드 (ERR001, ERR002 등)
    user_code VARCHAR(50),                          -- 에러 발생 사용자 (있는 경우)
    store_code VARCHAR(50),                         -- 관련 매장 (있는 경우)
    platform_code VARCHAR(50),                     -- 관련 플랫폼 매장
    store_name VARCHAR(100),                        -- 매장 이름 (빠른 식별용)
    
    -- 에러 분류
    category VARCHAR(50) NOT NULL,                  -- 에러 카테고리: '시스템오류', '크롤링실패', '답글등록실패', '결제오류', '권한오류'
    severity VARCHAR(20) NOT NULL,                  -- 심각도: 'low', 'medium', 'high', 'critical'
    platform VARCHAR(20),                          -- 관련 플랫폼
    error_type VARCHAR(100) NOT NULL,               -- 구체적 에러 유형
    
    -- 에러 상세 정보
    error_message TEXT NOT NULL,                    -- 에러 메시지
    stack_trace TEXT,                              -- 스택 트레이스 (개발용)
    request_data JSONB,                            -- 요청 데이터 (디버깅용)
    response_data JSONB,                           -- 응답 데이터
    user_agent TEXT,                               -- 사용자 브라우저 정보
    ip_address INET,                               -- 클라이언트 IP
    
    -- 발생 환경
    server_instance VARCHAR(50),                    -- 서버 인스턴스 식별자
    environment VARCHAR(20) DEFAULT 'production',   -- 환경: 'development', 'staging', 'production'
    version VARCHAR(20),                           -- 애플리케이션 버전
    
    -- 처리 상태
    status VARCHAR(20) DEFAULT 'new',               -- 처리 상태: 'new', 'investigating', 'resolved', 'ignored'
    assigned_to VARCHAR(50),                        -- 담당자
    resolution_notes TEXT,                          -- 해결 방법 메모
    resolved_at TIMESTAMP,                          -- 해결 시간
    
    -- 발생 시간
    occurred_at TIMESTAMP DEFAULT NOW(),            -- 에러 발생 시간
    first_occurrence TIMESTAMP DEFAULT NOW(),       -- 최초 발생 시간 (같은 에러의 경우)
    occurrence_count INTEGER DEFAULT 1,             -- 발생 횟수
    last_occurrence TIMESTAMP DEFAULT NOW(),        -- 마지막 발생 시간
    
    created_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (user_code) REFERENCES users(user_code)
);

-- 시스템 성능 로그 테이블
-- 역할: 시스템 성능 지표와 리소스 사용량을 추적
-- 성능 최적화, 용량 계획, SLA 모니터링에 활용
CREATE TABLE system_performance_logs (
    id SERIAL PRIMARY KEY,
    metric_type VARCHAR(50) NOT NULL,               -- 메트릭 유형: 'cpu_usage', 'memory_usage', 'disk_usage', 'response_time', 'throughput'
    metric_name VARCHAR(100) NOT NULL,              -- 구체적 메트릭명
    value DECIMAL(15,6) NOT NULL,                   -- 측정값
    unit VARCHAR(20),                               -- 단위: '%', 'ms', 'MB', 'requests/sec'
    server_instance VARCHAR(50),                    -- 서버 인스턴스
    service_name VARCHAR(50),                       -- 서비스명: 'web', 'api', 'crawler', 'database'
    tags JSONB,                                     -- 추가 태그: {"endpoint": "/api/reviews", "method": "POST"}
    threshold_warning DECIMAL(15,6),                -- 경고 임계값
    threshold_critical DECIMAL(15,6),               -- 위험 임계값
    is_anomaly BOOLEAN DEFAULT false,               -- 이상치 여부
    recorded_at TIMESTAMP DEFAULT NOW()
);

-- 사용자 활동 로그 테이블
-- 역할: 사용자의 모든 중요한 활동을 추적
-- 보안 감사, 사용 패턴 분석, 사용자 행동 분석에 활용
CREATE TABLE user_activity_logs (
    id SERIAL PRIMARY KEY,
    user_code VARCHAR(50) NOT NULL,                 -- 활동한 사용자
    session_id VARCHAR(100),                        -- 세션 ID
    activity_type VARCHAR(50) NOT NULL,             -- 활동 유형: 'login', 'logout', 'view', 'edit', 'delete', 'download', 'api_call'
    resource_type VARCHAR(50),                      -- 대상 리소스: 'store', 'review', 'setting', 'payment'
    resource_id VARCHAR(100),                       -- 대상 리소스 ID
    action_details JSONB,                           -- 활동 상세 정보
    
    -- 요청 정보
    ip_address INET,                                -- 클라이언트 IP
    user_agent TEXT,                                -- 브라우저 정보
    referrer TEXT,                                  -- 이전 페이지
    request_method VARCHAR(10),                     -- HTTP 메서드
    request_url TEXT,                               -- 요청 URL
    
    -- 결과 정보
    status_code INTEGER,                            -- HTTP 상태 코드
    response_time_ms INTEGER,                       -- 응답 시간
    error_message TEXT,                             -- 에러 메시지 (실패시)
    
    -- 보안 관련
    is_suspicious BOOLEAN DEFAULT false,            -- 의심스러운 활동 여부
    security_flags TEXT[],                          -- 보안 플래그: ['unusual_ip', 'high_frequency', 'after_hours']
    
    occurred_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (user_code) REFERENCES users(user_code)
);

-- =====================================
-- 8. API 및 외부 연동 테이블
-- =====================================

-- API 키 관리 테이블
-- 역할: 외부 연동을 위한 API 키 생성 및 관리
-- 엔터프라이즈 고객의 자체 시스템 연동, 써드파티 서비스 연동 지원
CREATE TABLE api_keys (
    id SERIAL PRIMARY KEY,
    api_key VARCHAR(100) UNIQUE NOT NULL,           -- API 키 (해시값)
    api_secret VARCHAR(100),                        -- API 시크릿 (해시값)
    user_code VARCHAR(50) NOT NULL,                 -- API 키 소유자
    key_name VARCHAR(100) NOT NULL,                 -- API 키 이름 (관리용)
    description TEXT,                               -- API 키 용도 설명
    
    -- 권한 설정
    permissions JSONB NOT NULL,                     -- 권한 설정: {"reviews": {"read": true, "write": false}, "stores": {"read": true}}
    allowed_ips TEXT[],                             -- 허용 IP 목록 (빈 배열=제한없음)
    allowed_domains TEXT[],                         -- 허용 도메인 목록
    
    -- 사용량 제한
    rate_limit_per_hour INTEGER DEFAULT 1000,       -- 시간당 요청 제한
    rate_limit_per_day INTEGER DEFAULT 10000,       -- 일일 요청 제한
    monthly_quota INTEGER,                          -- 월간 할당량 (NULL=무제한)
    
    -- 상태 관리
    is_active BOOLEAN DEFAULT true,                 -- API 키 활성화 상태
    expires_at TIMESTAMP,                           -- 만료 시간 (NULL=무제한)
    last_used TIMESTAMP,                            -- 마지막 사용 시간
    usage_count INTEGER DEFAULT 0,                  -- 총 사용 횟수
    
    -- 보안
    webhook_url TEXT,                               -- 이벤트 수신 웹훅 URL
    webhook_secret VARCHAR(100),                    -- 웹훅 검증용 시크릿
    
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (user_code) REFERENCES users(user_code)
);

-- API 사용 로그 테이블
-- 역할: 모든 API 호출을 상세하게 기록
-- API 사용량 추적, 과금, 보안 모니터링, 성능 분석에 활용
CREATE TABLE api_usage_logs (
    id SERIAL PRIMARY KEY,
    api_key_id INTEGER NOT NULL,                    -- 사용된 API 키
    user_code VARCHAR(50) NOT NULL,                 -- API 키 소유자
    
    -- 요청 정보
    endpoint VARCHAR(200) NOT NULL,                 -- 호출된 엔드포인트
    method VARCHAR(10) NOT NULL,                    -- HTTP 메서드
    request_headers JSONB,                          -- 요청 헤더
    request_body JSONB,                             -- 요청 본문 (민감정보 제외)
    query_params JSONB,                             -- 쿼리 파라미터
    
    -- 응답 정보
    status_code INTEGER NOT NULL,                   -- HTTP 응답 코드
    response_size INTEGER,                          -- 응답 크기 (바이트)
    response_time_ms INTEGER,                       -- 응답 시간 (밀리초)
    error_message TEXT,                             -- 에러 메시지 (실패시)
    
    -- 클라이언트 정보
    ip_address INET,                                -- 클라이언트 IP
    user_agent TEXT,                                -- User-Agent
    referer TEXT,                                   -- Referer 헤더
    
    -- 사용량 계산
    quota_consumed INTEGER DEFAULT 1,               -- 소비된 할당량
    cost_credits DECIMAL(10,4),                     -- 소비된 크레딧 (과금용)
    
    requested_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (api_key_id) REFERENCES api_keys(id),
    FOREIGN KEY (user_code) REFERENCES users(user_code)
);

-- =====================================
-- 9. 시스템 설정 및 관리 테이블
-- =====================================

-- 시스템 설정 테이블
-- 역할: 전역 시스템 설정을 동적으로 관리
-- 코드 수정 없이 운영 중 설정 변경 가능
CREATE TABLE system_settings (
    id SERIAL PRIMARY KEY,
    setting_key VARCHAR(100) UNIQUE NOT NULL,       -- 설정 키 (고유값)
    setting_value TEXT NOT NULL,                    -- 설정 값 (JSON 문자열 가능)
    data_type VARCHAR(20) DEFAULT 'string',         -- 데이터 타입: 'string', 'integer', 'boolean', 'json'
    category VARCHAR(50),                           -- 설정 카테고리: 'system', 'ai', 'crawler', 'payment', 'notification'
    description TEXT,                               -- 설정 설명
    is_public BOOLEAN DEFAULT false,                -- 일반 사용자 접근 가능 여부
    is_sensitive BOOLEAN DEFAULT false,             -- 민감 정보 여부 (로그 마스킹)
    validation_regex VARCHAR(500),                  -- 값 검증용 정규식
    default_value TEXT,                             -- 기본값
    updated_by VARCHAR(50),                         -- 마지막 수정자
    updated_at TIMESTAMP DEFAULT NOW(),
    created_at TIMESTAMP DEFAULT NOW()
);

-- 기능 플래그 테이블
-- 역할: 새로운 기능의 점진적 출시 및 A/B 테스트 관리
-- 사용자 그룹별로 다른 기능을 제공하여 안전한 기능 배포
CREATE TABLE feature_flags (
    id SERIAL PRIMARY KEY,
    flag_name VARCHAR(100) UNIQUE NOT NULL,         -- 기능 플래그 이름
    display_name VARCHAR(200),                      -- 표시용 이름
    description TEXT,                               -- 기능 설명
    flag_type VARCHAR(20) DEFAULT 'boolean',        -- 플래그 타입: 'boolean', 'string', 'number', 'json'
    default_value TEXT NOT NULL,                    -- 기본값
    
    -- 활성화 조건
    is_enabled BOOLEAN DEFAULT false,               -- 전역 활성화 여부
    rollout_percentage INTEGER DEFAULT 0,           -- 롤아웃 비율 (0-100%)
    target_user_roles TEXT[],                       -- 대상 사용자 역할
    target_plan_codes TEXT[],                       -- 대상 요금제
    environment_restriction TEXT[],                 -- 환경 제한: ['development', 'staging', 'production']
    
    -- 조건부 활성화
    activation_rules JSONB,                         -- 활성화 규칙: {"user_count": {"min": 100}, "signup_date": {"after": "2024-01-01"}}
    start_date TIMESTAMP,                           -- 활성화 시작일
    end_date TIMESTAMP,                             -- 활성화 종료일
    
    created_by VARCHAR(50),                         -- 생성자
    updated_by VARCHAR(50),                         -- 수정자
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 사용자별 기능 플래그 상태 테이블
-- 역할: 특정 사용자에게 개별적으로 적용된 기능 플래그 추적
-- 베타 테스터, VIP 고객 등에게 특별 기능 제공
CREATE TABLE user_feature_flags (
    id SERIAL PRIMARY KEY,
    user_code VARCHAR(50) NOT NULL,                 -- 사용자
    flag_name VARCHAR(100) NOT NULL,                -- 기능 플래그명
    flag_value TEXT NOT NULL,                       -- 해당 사용자에게 적용된 값
    is_forced BOOLEAN DEFAULT false,                -- 강제 적용 여부 (전역 설정 무시)
    reason TEXT,                                    -- 개별 적용 사유
    applied_by VARCHAR(50),                         -- 적용한 관리자
    expires_at TIMESTAMP,                           -- 만료 시간
    created_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (user_code) REFERENCES users(user_code),
    UNIQUE(user_code, flag_name)
);

-- =====================================
-- 인덱스 생성 (성능 최적화)
-- =====================================

-- 사용자 관련 인덱스
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role_active ON users(role, is_active);
CREATE INDEX idx_users_signup_date ON users(signup_date);

-- 구독 관련 인덱스
CREATE INDEX idx_subscriptions_user_status ON subscriptions(user_code, status);
CREATE INDEX idx_subscriptions_end_date ON subscriptions(end_date);
CREATE INDEX idx_subscriptions_auto_renewal ON subscriptions(auto_renewal, end_date) WHERE status = 'active';

-- 결제 관련 인덱스
CREATE INDEX idx_payments_user_status ON payments(user_code, status);
CREATE INDEX idx_payments_created_at ON payments(created_at);
CREATE INDEX idx_payments_gateway_transaction ON payments(payment_gateway, gateway_transaction_id);

-- 사용량 추적 인덱스
CREATE INDEX idx_usage_tracking_user_month ON usage_tracking(user_code, tracking_month);
CREATE INDEX idx_rate_limits_user_type ON rate_limits(user_code, limit_type);

-- 매장 관련 인덱스
CREATE INDEX idx_platform_rules_owner ON platform_reply_rules(owner_user_code, is_active);
CREATE INDEX idx_platform_rules_platform ON platform_reply_rules(platform, platform_code);
CREATE INDEX idx_user_permissions_user ON user_store_permissions(user_code, is_active);

-- 리뷰 관련 인덱스
CREATE INDEX idx_reviews_store_status ON reviews(store_code, response_status);
CREATE INDEX idx_reviews_platform_date ON reviews(platform, review_date);
CREATE INDEX idx_reviews_boss_reply ON reviews(boss_reply_needed, created_at) WHERE boss_reply_needed = true;
CREATE INDEX idx_reviews_rating_date ON reviews(rating, review_date);

-- 알림 관련 인덱스
CREATE INDEX idx_alert_settings_user_active ON alert_settings(user_code, is_active);
CREATE INDEX idx_alert_logs_user_type ON alert_logs(user_code, alert_type, created_at);
CREATE INDEX idx_alert_logs_status ON alert_logs(status, created_at);

-- 에러 로그 인덱스
CREATE INDEX idx_error_logs_category_severity ON error_logs(category, severity, occurred_at);
CREATE INDEX idx_error_logs_store_platform ON error_logs(store_code, platform, occurred_at);

-- API 관련 인덱스
CREATE INDEX idx_api_keys_user_active ON api_keys(user_code, is_active);
CREATE INDEX idx_api_usage_user_date ON api_usage_logs(user_code, requested_at);

-- =====================================
-- 기본 데이터 삽입
-- =====================================

-- 기본 요금제 데이터
INSERT INTO pricing_plans (plan_code, plan_name, description, monthly_price, yearly_price, yearly_discount_rate, max_stores, max_reviews_per_month, max_users, features, trial_days, is_popular) VALUES 
('FREE_TRIAL', '무료 체험', '7일 무료 체험으로 서비스 경험해보세요', 0.00, 0.00, 0, 2, 50, 1, '{"ai_reply": true, "analytics": false, "priority_support": false, "api_access": false}', 7, false),
('BASIC', '베이직', '개인 사장님에게 최적화된 기본 플랜', 29000.00, 290000.00, 17, 5, 500, 1, '{"ai_reply": true, "analytics": true, "priority_support": false, "api_access": false, "custom_rules": false}', 0, false),
('PRO', '프로', '다매장 운영자를 위한 프리미엄 플랜', 59000.00, 590000.00, 17, 20, 2000, 3, '{"ai_reply": true, "analytics": true, "priority_support": true, "api_access": true, "custom_rules": true, "advanced_analytics": true}', 0, true),
('ENTERPRISE', '엔터프라이즈', '프랜차이즈 및 대기업을 위한 맞춤 솔루션', 150000.00, 1500000.00, 17, 100, 10000, 10, '{"ai_reply": true, "analytics": true, "priority_support": true, "api_access": true, "custom_rules": true, "advanced_analytics": true, "white_label": true, "dedicated_support": true}', 0, false);

-- 기본 시스템 설정
INSERT INTO system_settings (setting_key, setting_value, data_type, category, description, is_public) VALUES 
('trial_period_days', '7', 'integer', 'system', '무료 체험 기간 (일)', true),
('max_retry_count', '5', 'integer', 'crawler', '답글 등록 최대 재시도 횟수', false),
('ai_processing_hours', '10:00-20:00', 'string', 'ai', 'AI 답글 처리 시간대', true),
('maintenance_mode', 'false', 'boolean', 'system', '점검 모드 여부', true),
('service_announcement', '', 'string', 'system', '서비스 공지사항', true),
('default_timezone', 'Asia/Seoul', 'string', 'system', '기본 시간대', true),
('max_concurrent_crawlers', '10', 'integer', 'crawler', '최대 동시 크롤러 수', false),
('ai_model_version', 'gpt-4o-mini', 'string', 'ai', '사용 중인 AI 모델', false),
('payment_webhook_timeout', '30', 'integer', 'payment', '결제 웹훅 타임아웃 (초)', false),
('default_reply_delay', '30', 'integer', 'ai', '기본 답글 지연 시간 (분)', true);

-- 기본 기능 플래그
INSERT INTO feature_flags (flag_name, display_name, description, flag_type, default_value, is_enabled, rollout_percentage) VALUES 
('advanced_analytics', '고급 분석', '상세한 리뷰 분석 및 인사이트 제공', 'boolean', 'false', true, 100),
('beta_multi_language', '다국어 지원 (베타)', '영어, 중국어 등 다국어 리뷰 처리', 'boolean', 'false', false, 10),
('experimental_voice_reply', '음성 답글 (실험)', 'AI 음성으로 답글 생성', 'boolean', 'false', false, 0),
('new_dashboard_ui', '새로운 대시보드', '개선된 사용자 인터페이스', 'boolean', 'false', true, 50);

-- 관리자 계정 생성 (비밀번호는 실제로는 해시화되어야 함)
INSERT INTO users (user_code, email, password_hash, name, role, email_verified, is_active) VALUES 
('ADMIN001', 'admin@reviewbot.co.kr', '$2b$12$LQv3c1yqBwkvHiOWlK.DE.JK1k2Gv.K1uK1KvK1K1K1K1K1K1K1K1', '시스템관리자', 'admin', true, true),
('SUPPORT001', 'support@reviewbot.co.kr', '$2b$12$LQv3c1yqBwkvHiOWlK.DE.JK1k2Gv.K1uK1KvK1K1K1K1K1K1K1K1', '고객지원팀', 'admin', true, true);

-- =====================================
-- 유틸리티 함수 및 프로시저
-- =====================================

-- 구독 상태 체크 함수
-- 역할: 사용자의 현재 구독 상태와 사용 가능한 리소스를 확인
-- 자동화 실행 전 호출하여 서비스 이용 가능 여부 판단
CREATE OR REPLACE FUNCTION check_subscription_status(p_user_code VARCHAR(50))
RETURNS TABLE(
    is_active BOOLEAN,
    plan_name VARCHAR(100),
    plan_code VARCHAR(50),
    end_date DATE,
    remaining_stores INTEGER,
    remaining_reviews INTEGER,
    subscription_status VARCHAR(20),
    days_until_expiry INTEGER
) AS $
DECLARE
    current_sub RECORD;
    current_usage RECORD;
    current_month DATE;
    store_count INTEGER;
BEGIN
    current_month := DATE_TRUNC('month', CURRENT_DATE);
    
    -- 활성 구독 조회 (만료일이 가장 늦은 것 우선)
    SELECT s.*, p.plan_name, p.max_stores, p.max_reviews_per_month
    INTO current_sub
    FROM subscriptions s
    JOIN pricing_plans p ON s.plan_code = p.plan_code
    WHERE s.user_code = p_user_code 
    AND s.status IN ('active', 'trial') 
    AND s.end_date >= CURRENT_DATE
    ORDER BY s.end_date DESC, s.created_at DESC
    LIMIT 1;
    
    -- 이번 달 사용량 조회
    SELECT COALESCE(stores_count, 0) as stores_count, 
           COALESCE(reviews_processed, 0) as reviews_processed
    INTO current_usage
    FROM usage_tracking
    WHERE user_code = p_user_code AND tracking_month = current_month;
    
    -- 현재 등록된 활성 매장 수 조회
    SELECT COUNT(DISTINCT store_code)
    INTO store_count
    FROM platform_reply_rules
    WHERE owner_user_code = p_user_code AND is_active = true;
    
    IF current_sub.subscription_code IS NOT NULL THEN
        RETURN QUERY SELECT 
            true as is_active,
            current_sub.plan_name,
            current_sub.plan_code,
            current_sub.end_date,
            GREATEST(0, current_sub.max_stores - store_count) as remaining_stores,
            GREATEST(0, current_sub.max_reviews_per_month - COALESCE(current_usage.reviews_processed, 0)) as remaining_reviews,
            current_sub.status as subscription_status,
            (current_sub.end_date - CURRENT_DATE)::INTEGER as days_until_expiry;
    ELSE
        RETURN QUERY SELECT 
            false as is_active,
            ''::VARCHAR(100) as plan_name,
            ''::VARCHAR(50) as plan_code,
            CURRENT_DATE as end_date,
            0 as remaining_stores,
            0 as remaining_reviews,
            'no_subscription'::VARCHAR(20) as subscription_status,
            0 as days_until_expiry;
    END IF;
END;
$ LANGUAGE plpgsql;

-- 사용량 업데이트 함수
-- 역할: 사용자의 월별 사용량을 실시간으로 업데이트
-- 답글 처리, 매장 등록 등의 이벤트 발생시 호출
CREATE OR REPLACE FUNCTION update_usage(
    p_user_code VARCHAR(50),
    p_reviews_increment INTEGER DEFAULT 0,
    p_manual_replies_increment INTEGER DEFAULT 0,
    p_ai_api_calls_increment INTEGER DEFAULT 0,
    p_web_api_calls_increment INTEGER DEFAULT 0,
    p_stores_count INTEGER DEFAULT NULL,
    p_error_increment INTEGER DEFAULT 0
) RETURNS VOID AS $
DECLARE
    current_month DATE;
    current_store_count INTEGER;
BEGIN
    current_month := DATE_TRUNC('month', CURRENT_DATE);
    
    -- 현재 활성 매장 수 계산 (p_stores_count가 NULL인 경우)
    IF p_stores_count IS NULL THEN
        SELECT COUNT(DISTINCT store_code)
        INTO current_store_count
        FROM platform_reply_rules
        WHERE owner_user_code = p_user_code AND is_active = true;
    ELSE
        current_store_count := p_stores_count;
    END IF;
    
    -- 사용량 업데이트 (UPSERT)
    INSERT INTO usage_tracking (
        user_code, tracking_month, reviews_processed, manual_replies, 
        ai_api_calls, web_api_calls, stores_count, error_count, last_updated
    )
    VALUES (
        p_user_code, current_month, p_reviews_increment, p_manual_replies_increment,
        p_ai_api_calls_increment, p_web_api_calls_increment, current_store_count, p_error_increment, NOW()
    )
    ON CONFLICT (user_code, tracking_month)
    DO UPDATE SET
        reviews_processed = usage_tracking.reviews_processed + p_reviews_increment,
        manual_replies = usage_tracking.manual_replies + p_manual_replies_increment,
        ai_api_calls = usage_tracking.ai_api_calls + p_ai_api_calls_increment,
        web_api_calls = usage_tracking.web_api_calls + p_web_api_calls_increment,
        stores_count = current_store_count,
        error_count = usage_tracking.error_count + p_error_increment,
        last_updated = NOW();
        
    -- Rate Limit 업데이트
    INSERT INTO rate_limits (user_code, limit_type, current_count, max_limit, reset_period, reset_at)
    VALUES (p_user_code, 'reviews_per_hour', p_reviews_increment, 100, 'hourly', DATE_TRUNC('hour', NOW()) + INTERVAL '1 hour')
    ON CONFLICT (user_code, limit_type)
    DO UPDATE SET
        current_count = CASE 
            WHEN rate_limits.reset_at <= NOW() THEN p_reviews_increment
            ELSE rate_limits.current_count + p_reviews_increment
        END,
        reset_at = CASE
            WHEN rate_limits.reset_at <= NOW() THEN DATE_TRUNC('hour', NOW()) + INTERVAL '1 hour'
            ELSE rate_limits.reset_at
        END,
        updated_at = NOW();
END;
$ LANGUAGE plpgsql;

-- 만료된 구독 자동 처리 함수 (Cron Job용)
-- 역할: 만료된 구독을 자동으로 처리하고 관련 서비스 중단
-- 매일 자정에 실행하여 만료된 구독을 정리
CREATE OR REPLACE FUNCTION process_expired_subscriptions() RETURNS TABLE(
    expired_count INTEGER,
    suspended_stores INTEGER,
    notifications_sent INTEGER
) AS $
DECLARE
    expired_subs INTEGER;
    suspended_stores INTEGER;
    notifications_sent INTEGER;
    sub_record RECORD;
BEGIN
    -- 만료된 구독 업데이트
    UPDATE subscriptions 
    SET status = 'expired', updated_at = NOW()
    WHERE status = 'active' 
    AND end_date < CURRENT_DATE;
    
    GET DIAGNOSTICS expired_subs = ROW_COUNT;
    
    -- 만료된 구독의 매장들 비활성화
    UPDATE platform_reply_rules 
    SET is_active = false, updated_at = NOW()
    WHERE owner_user_code IN (
        SELECT user_code FROM subscriptions 
        WHERE status = 'expired' 
        AND updated_at >= CURRENT_DATE  -- 오늘 만료된 것만
    );
    
    GET DIAGNOSTICS suspended_stores = ROW_COUNT;
    
    -- 만료 알림 발송 (만료 3일 전, 1일 전, 만료일 당일)
    notifications_sent := 0;
    
    FOR sub_record IN 
        SELECT s.user_code, s.end_date, s.subscription_code, u.email, u.name, p.plan_name
        FROM subscriptions s
        JOIN users u ON s.user_code = u.user_code
        JOIN pricing_plans p ON s.plan_code = p.plan_code
        WHERE s.status = 'active'
        AND s.end_date IN (CURRENT_DATE + 3, CURRENT_DATE + 1, CURRENT_DATE)
    LOOP
        -- 알림 로그 삽입 (실제 발송은 별도 시스템에서 처리)
        INSERT INTO alert_logs (
            user_code, alert_type, channel, message, status, 
            subject, recipient_info
        ) VALUES (
            sub_record.user_code,
            'subscription_expiring',
            'email',
            FORMAT('구독이 %s에 만료됩니다. 계속 이용하시려면 갱신해주세요.', sub_record.end_date),
            'pending',
            FORMAT('[중요] %s 구독 만료 알림', sub_record.plan_name),
            JSON_BUILD_OBJECT('email', sub_record.email, 'name', sub_record.name)
        );
        
        notifications_sent := notifications_sent + 1;
    END LOOP;
    
    RETURN QUERY SELECT expired_subs, suspended_stores, notifications_sent;
END;
$ LANGUAGE plpgsql;

-- 사용자 권한 확인 함수
-- 역할: 특정 작업에 대한 사용자 권한을 체크
-- API 호출, 웹 요청 시 권한 검증에 사용
CREATE OR REPLACE FUNCTION check_user_permission(
    p_user_code VARCHAR(50),
    p_store_code VARCHAR(50),
    p_action VARCHAR(50)
) RETURNS BOOLEAN AS $
DECLARE
    user_role VARCHAR(20);
    has_permission BOOLEAN := false;
    store_owner VARCHAR(50);
BEGIN
    -- 사용자 역할 조회
    SELECT role INTO user_role FROM users WHERE user_code = p_user_code AND is_active = true;
    
    IF user_role IS NULL THEN
        RETURN false;
    END IF;
    
    -- 관리자는 모든 권한
    IF user_role = 'admin' THEN
        RETURN true;
    END IF;
    
    -- 매장 소유자 확인
    SELECT owner_user_code INTO store_owner 
    FROM platform_reply_rules 
    WHERE store_code = p_store_code AND is_active = true
    LIMIT 1;
    
    -- 소유자는 모든 권한
    IF store_owner = p_user_code THEN
        RETURN true;
    END IF;
    
    -- 권한 테이블에서 확인
    SELECT 
        CASE p_action
            WHEN 'view' THEN can_view
            WHEN 'edit' THEN can_edit_settings
            WHEN 'reply' THEN can_reply
            WHEN 'manage_rules' THEN can_manage_rules
            WHEN 'manage_alerts' THEN can_manage_alerts
            WHEN 'view_analytics' THEN can_view_analytics
            WHEN 'export_data' THEN can_export_data
            ELSE false
        END
    INTO has_permission
    FROM user_store_permissions
    WHERE user_code = p_user_code 
    AND store_code = p_store_code 
    AND is_active = true
    AND (expires_at IS NULL OR expires_at > NOW());
    
    RETURN COALESCE(has_permission, false);
END;
$ LANGUAGE plpgsql;

-- 리뷰 통계 계산 함수
-- 역할: 매장별 리뷰 통계를 실시간으로 계산
-- 대시보드, 분석 리포트에서 사용
CREATE OR REPLACE FUNCTION calculate_review_stats(
    p_store_code VARCHAR(50),
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
) RETURNS TABLE(
    total_reviews INTEGER,
    avg_rating DECIMAL(3,2),
    total_replies INTEGER,
    reply_rate DECIMAL(5,2),
    avg_response_time_hours DECIMAL(6,2),
    positive_reviews INTEGER,
    negative_reviews INTEGER,
    boss_review_needed INTEGER
) AS $
DECLARE
    date_filter_start DATE;
    date_filter_end DATE;
BEGIN
    -- 기본 날짜 범위 설정 (최근 30일)
    date_filter_start := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '30 days');
    date_filter_end := COALESCE(p_end_date, CURRENT_DATE);
    
    RETURN QUERY
    SELECT 
        COUNT(*)::INTEGER as total_reviews,
        ROUND(AVG(rating), 2) as avg_rating,
        COUNT(CASE WHEN response_status = 'posted' THEN 1 END)::INTEGER as total_replies,
        ROUND(
            COUNT(CASE WHEN response_status = 'posted' THEN 1 END) * 100.0 / 
            NULLIF(COUNT(*), 0), 2
        ) as reply_rate,
        ROUND(
            AVG(EXTRACT(EPOCH FROM (response_at - created_at)) / 3600), 2
        ) as avg_response_time_hours,
        COUNT(CASE WHEN rating >= 4 THEN 1 END)::INTEGER as positive_reviews,
        COUNT(CASE WHEN rating <= 2 THEN 1 END)::INTEGER as negative_reviews,
        COUNT(CASE WHEN boss_reply_needed = true THEN 1 END)::INTEGER as boss_review_needed
    FROM reviews
    WHERE store_code = p_store_code
    AND review_date BETWEEN date_filter_start AND date_filter_end
    AND is_deleted = false;
END;
$ LANGUAGE plpgsql;

-- API 요청 제한 확인 함수
-- 역할: API 키의 요청 제한을 실시간으로 확인
-- API 호출 시 rate limiting 적용
CREATE OR REPLACE FUNCTION check_api_rate_limit(
    p_api_key VARCHAR(100)
) RETURNS TABLE(
    is_allowed BOOLEAN,
    remaining_requests INTEGER,
    reset_time TIMESTAMP,
    limit_type VARCHAR(20)
) AS $
DECLARE
    api_record RECORD;
    current_hour TIMESTAMP;
    current_day DATE;
    hourly_count INTEGER;
    daily_count INTEGER;
BEGIN
    current_hour := DATE_TRUNC('hour', NOW());
    current_day := CURRENT_DATE;
    
    -- API 키 정보 조회
    SELECT ak.*, u.user_code, s.status as subscription_status
    INTO api_record
    FROM api_keys ak
    JOIN users u ON ak.user_code = u.user_code
    LEFT JOIN subscriptions s ON u.user_code = s.user_code AND s.status = 'active'
    WHERE ak.api_key = p_api_key 
    AND ak.is_active = true
    AND (ak.expires_at IS NULL OR ak.expires_at > NOW());
    
    IF api_record.api_key IS NULL THEN
        RETURN QUERY SELECT false, 0, NOW(), 'invalid_key'::VARCHAR(20);
        RETURN;
    END IF;
    
    -- 구독 상태 확인
    IF api_record.subscription_status IS NULL THEN
        RETURN QUERY SELECT false, 0, NOW(), 'no_subscription'::VARCHAR(20);
        RETURN;
    END IF;
    
    -- 시간당 사용량 확인
    SELECT COUNT(*)::INTEGER
    INTO hourly_count
    FROM api_usage_logs
    WHERE api_key_id = (SELECT id FROM api_keys WHERE api_key = p_api_key)
    AND requested_at >= current_hour;
    
    -- 일일 사용량 확인
    SELECT COUNT(*)::INTEGER
    INTO daily_count
    FROM api_usage_logs
    WHERE api_key_id = (SELECT id FROM api_keys WHERE api_key = p_api_key)
    AND requested_at >= current_day;
    
    -- 제한 확인
    IF hourly_count >= api_record.rate_limit_per_hour THEN
        RETURN QUERY SELECT false, 0, current_hour + INTERVAL '1 hour', 'hourly_limit'::VARCHAR(20);
    ELSIF daily_count >= api_record.rate_limit_per_day THEN
        RETURN QUERY SELECT false, 0, (current_day + 1)::TIMESTAMP, 'daily_limit'::VARCHAR(20);
    ELSE
        RETURN QUERY SELECT 
            true, 
            LEAST(
                api_record.rate_limit_per_hour - hourly_count,
                api_record.rate_limit_per_day - daily_count
            ), 
            current_hour + INTERVAL '1 hour', 
            'allowed'::VARCHAR(20);
    END IF;
END;
$ LANGUAGE plpgsql;

-- =====================================
-- 유용한 뷰 (View) 생성
-- =====================================

-- 사용자 대시보드 뷰
-- 역할: 사용자별 주요 정보를 한눈에 볼 수 있는 통합 뷰
CREATE VIEW v_user_dashboard AS
SELECT 
    u.user_code,
    u.name as user_name,
    u.email,
    u.role,
    s.plan_code,
    p.plan_name,
    s.status as subscription_status,
    s.end_date as subscription_end,
    ut.stores_count,
    ut.reviews_processed as monthly_reviews,
    p.max_reviews_per_month,
    p.max_stores,
    CASE 
        WHEN s.status = 'active' AND s.end_date >= CURRENT_DATE THEN true
        ELSE false
    END as is_subscription_active,
    (s.end_date - CURRENT_DATE) as days_until_expiry,
    u.last_login,
    ut.last_updated as last_activity
FROM users u
LEFT JOIN subscriptions s ON u.user_code = s.user_code AND s.status IN ('active', 'trial')
LEFT JOIN pricing_plans p ON s.plan_code = p.plan_code
LEFT JOIN usage_tracking ut ON u.user_code = ut.user_code 
    AND ut.tracking_month = DATE_TRUNC('month', CURRENT_DATE)
WHERE u.is_active = true;

-- 매장 성과 뷰
-- 역할: 매장별 리뷰 및 답글 성과를 종합적으로 보여주는 뷰
CREATE VIEW v_store_performance AS
SELECT 
    pr.store_code,
    pr.store_name,
    pr.platform,
    pr.platform_code,
    u.name as owner_name,
    COUNT(r.id) as total_reviews,
    ROUND(AVG(r.rating), 2) as avg_rating,
    COUNT(CASE WHEN r.response_status = 'posted' THEN 1 END) as replied_reviews,
    ROUND(
        COUNT(CASE WHEN r.response_status = 'posted' THEN 1 END) * 100.0 / 
        NULLIF(COUNT(r.id), 0), 2
    ) as reply_rate,
    COUNT(CASE WHEN r.boss_reply_needed = true THEN 1 END) as pending_manual_reviews,
    COUNT(CASE WHEN r.rating >= 4 THEN 1 END) as positive_reviews,
    COUNT(CASE WHEN r.rating <= 2 THEN 1 END) as negative_reviews,
    pr.last_crawled,
    pr.last_reply,
    pr.is_active
FROM platform_reply_rules pr
JOIN users u ON pr.owner_user_code = u.user_code
LEFT JOIN reviews r ON pr.store_code = r.store_code 
    AND r.review_date >= CURRENT_DATE - INTERVAL '30 days'
    AND r.is_deleted = false
WHERE pr.is_active = true
GROUP BY pr.store_code, pr.store_name, pr.platform, pr.platform_code, u.name, 
         pr.last_crawled, pr.last_reply, pr.is_active;

-- 시스템 건강성 뷰
-- 역할: 시스템 전반의 상태를 모니터링하는 뷰
CREATE VIEW v_system_health AS
SELECT 
    'active_users' as metric_name,
    COUNT(DISTINCT u.user_code)::TEXT as metric_value,
    'count' as metric_unit,
    CURRENT_TIMESTAMP as calculated_at
FROM users u
JOIN subscriptions s ON u.user_code = s.user_code
WHERE s.status = 'active' AND s.end_date >= CURRENT_DATE

UNION ALL

SELECT 
    'total_reviews_today',
    COUNT(*)::TEXT,
    'count',
    CURRENT_TIMESTAMP
FROM reviews
WHERE created_at >= CURRENT_DATE

UNION ALL

SELECT 
    'successful_replies_today',
    COUNT(*)::TEXT,
    'count',
    CURRENT_TIMESTAMP
FROM reviews
WHERE response_status = 'posted' 
AND response_at >= CURRENT_DATE

UNION ALL

SELECT 
    'error_rate_today',
    ROUND(
        COUNT(CASE WHEN severity IN ('high', 'critical') THEN 1 END) * 100.0 / 
        NULLIF(COUNT(*), 0), 2
    )::TEXT,
    'percentage',
    CURRENT_TIMESTAMP
FROM error_logs
WHERE occurred_at >= CURRENT_DATE;

-- =====================================
-- 트리거 생성 (자동화)
-- =====================================

-- 사용자 활동 시 last_login 업데이트 트리거
CREATE OR REPLACE FUNCTION update_user_last_login()
RETURNS TRIGGER AS $
BEGIN
    UPDATE users 
    SET last_login = NOW(), login_count = login_count + 1
    WHERE user_code = NEW.user_code 
    AND NEW.activity_type = 'login';
    RETURN NEW;
END;
$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_user_last_login
    AFTER INSERT ON user_activity_logs
    FOR EACH ROW EXECUTE FUNCTION update_user_last_login();

-- 리뷰 처리 시 매장 통계 업데이트 트리거
CREATE OR REPLACE FUNCTION update_store_stats()
RETURNS TRIGGER AS $
BEGIN
    IF NEW.response_status = 'posted' AND OLD.response_status != 'posted' THEN
        UPDATE platform_reply_rules
        SET 
            last_reply = NOW(),
            total_reviews_processed = total_reviews_processed + 1,
            updated_at = NOW()
        WHERE store_code = NEW.store_code;
    END IF;
    RETURN NEW;
END;
$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_store_stats
    AFTER UPDATE ON reviews
    FOR EACH ROW EXECUTE FUNCTION update_store_stats();

-- API 사용 시 사용량 자동 업데이트 트리거
CREATE OR REPLACE FUNCTION update_api_usage_stats()
RETURNS TRIGGER AS $
BEGIN
    UPDATE api_keys
    SET 
        last_used = NEW.requested_at,
        usage_count = usage_count + 1
    WHERE id = NEW.api_key_id;
    RETURN NEW;
END;
$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_api_usage_stats
    AFTER INSERT ON api_usage_logs
    FOR EACH ROW EXECUTE FUNCTION update_api_usage_stats();

-- =====================================
-- 권한 및 보안 설정
-- =====================================

-- 애플리케이션 사용자 생성 (실제 운영시 사용)
-- CREATE USER review_app_user WITH PASSWORD 'secure_password_here';
-- GRANT CONNECT ON DATABASE review_automation TO review_app_user;
-- GRANT USAGE ON SCHEMA public TO review_app_user;
-- GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO review_app_user;
-- GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO review_app_user;

-- 읽기 전용 사용자 생성 (분석/리포팅용)
-- CREATE USER review_readonly_user WITH PASSWORD 'readonly_password_here';
-- GRANT CONNECT ON DATABASE review_automation TO review_readonly_user;
-- GRANT USAGE ON SCHEMA public TO review_readonly_user;
-- GRANT SELECT ON ALL TABLES IN SCHEMA public TO review_readonly_user;

-- =====================================
-- 데이터 정리 및 보관 정책
-- =====================================

-- 90일 이상 된 로그 데이터 정리 함수
CREATE OR REPLACE FUNCTION cleanup_old_logs() RETURNS INTEGER AS $
DECLARE
    deleted_count INTEGER;
BEGIN
    -- 90일 이상 된 사용자 활동 로그 삭제
    DELETE FROM user_activity_logs 
    WHERE occurred_at < CURRENT_DATE - INTERVAL '90 days';
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    
    -- 90일 이상 된 API 사용 로그 정리 (통계용 요약 데이터는 유지)
    DELETE FROM api_usage_logs 
    WHERE requested_at < CURRENT_DATE - INTERVAL '90 days'
    AND status_code = 200;  -- 성공한 요청만 삭제 (에러는 더 오래 보관)
    
    -- 해결된 에러 로그 중 30일 이상 된 것 정리
    DELETE FROM error_logs 
    WHERE status = 'resolved' 
    AND resolved_at < CURRENT_DATE - INTERVAL '30 days';
    
    -- 발송 완료된 알림 로그 중 60일 이상 된 것 정리
    DELETE FROM alert_logs 
    WHERE status = 'delivered' 
    AND sent_at < CURRENT_DATE - INTERVAL '60 days';
    
    RETURN deleted_count;
END;
$ LANGUAGE plpgsql;

-- 매월 1일 자동 실행용 데이터 정리 작업
-- (Cron Job으로 설정: 0 2 1 * * psql -d review_automation -c "SELECT cleanup_old_logs();")

COMMENT ON DATABASE postgres IS '리뷰 자동화 SaaS 서비스 - 배민/요기요/쿠팡 리뷰 크롤링 및 AI 답글 자동화 시스템';

-- =====================================
-- 초기 테스트 데이터 (개발용)
-- =====================================

-- 테스트용 사용자 계정
INSERT INTO users (user_code, email, password_hash, name, role, email_verified, marketing_consent) VALUES 
('TST001', 'test.owner@example.com', '$2b$12$test_hash_here', '테스트사장님', 'owner', true, false),
('TST002', 'test.franchise@example.com', '$2b$12$test_hash_here', '테스트프랜차이즈', 'franchise', true, false),
('TST003', 'test.sales@example.com', '$2b$12$test_hash_here', '테스트영업자', 'sales', true, false);

-- 테스트용 구독
INSERT INTO subscriptions (subscription_code, user_code, plan_code, status, billing_cycle, start_date, end_date, payment_amount) VALUES 
('SUB_TST001', 'TST001', 'BASIC', 'active', 'monthly', CURRENT_DATE, CURRENT_DATE + INTERVAL '30 days', 29000.00),
('SUB_TST002', 'TST002', 'PRO', 'active', 'monthly', CURRENT_DATE, CURRENT_DATE + INTERVAL '30 days', 59000.00);

-- 테스트용 매장
INSERT INTO platform_reply_rules (store_code, store_name, platform, platform_code, platform_id, platform_pw, owner_user_code, greeting_start, greeting_end) VALUES 
('TST_STORE001', '테스트맛집', 'baemin', 'shop_test_001', 'test_baemin_id', 'test_password', 'TST001', '안녕하세요!', '감사합니다'),
('TST_STORE002', '테스트치킨집', 'baemin', 'shop_test_002', 'test_baemin_id2', 'test_password2', 'TST001', '반갑습니다', '좋은 하루 되세요');

-- 테스트용 권한 부여
INSERT INTO user_store_permissions (user_code, store_code, permission_level, can_view, can_edit_settings, can_reply, granted_by) VALUES 
('TST002', 'TST_STORE001', 'write', true, true, true, 'ADMIN001'),  -- 프랜차이즈가 매장 관리
('TST003', 'TST_STORE001', 'read', true, false, false, 'TST002');   -- 영업자는 조회만

-- =====================================
-- 스키마 완성 메시지
-- =====================================

DO $
BEGIN
    RAISE NOTICE '========================================';
    RAISE NOTICE '리뷰 자동화 SaaS 데이터베이스 스키마 생성 완료!';
    RAISE NOTICE '========================================';
    RAISE NOTICE '생성된 테이블: %개', (SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_type = 'BASE TABLE');
    RAISE NOTICE '생성된 함수: %개', (SELECT COUNT(*) FROM information_schema.routines WHERE routine_schema = 'public' AND routine_type = 'FUNCTION');
    RAISE NOTICE '생성된 뷰: %개', (SELECT COUNT(*) FROM information_schema.views WHERE table_schema = 'public');
    RAISE NOTICE '생성된 인덱스: %개', (SELECT COUNT(*) FROM pg_indexes WHERE schemaname = 'public');
    RAISE NOTICE '========================================';
    RAISE NOTICE '다음 단계:';
    RAISE NOTICE '1. 애플리케이션 연결 설정';
    RAISE NOTICE '2. 초기 관리자 계정 로그인';
    RAISE NOTICE '3. 요금제 및 시스템 설정 확인';
    RAISE NOTICE '4. 테스트 데이터로 기능 검증';
    RAISE NOTICE '========================================';
END $;